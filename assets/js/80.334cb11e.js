(window.webpackJsonp=window.webpackJsonp||[]).push([[80],{434:function(a,t,s){"use strict";s.r(t);var n=s(15),e=Object(n.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("p",[a._v("随着前端应用的业务功能越来越复杂、用户对于使用体验的要求越来越高，单页应用（SPA）成为前端应用的主流形式。大型单页应用最显著特点之一就是采用前端路由系统，通过改变 URL，在不重新请求页面的情况下，更新页面视图。")]),a._v(" "),t("p",[a._v("“更新视图但不重新请求页面”是前端路由原理的核心之一，目前在浏览器环境中这一功能的实现主要有两种方式：")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("利用 URL 中的 hash（“#”）")])]),a._v(" "),t("li",[t("p",[a._v("利用 History interface 在 HTML5 中新增的方法")])])]),a._v(" "),t("h2",{attrs:{id:"hash-模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hash-模式"}},[a._v("#")]),a._v(" hash 模式")]),a._v(" "),t("p",[a._v("hash（“#”）符号的本来作用是加在 URL 中指示网页中的位置：")]),a._v(" "),t("div",{staticClass:"language-javascript extra-class"},[t("pre",{pre:!0,attrs:{class:"language-javascript"}},[t("code",[a._v("www"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("iwangxing"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("cn"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),a._v("index"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("html#aboutme\n")])])]),t("p",[a._v("#符号本身以及它后面的字符称之为 hash，可通过 window.location.hash 属性读取。它具有如下特点：")]),a._v(" "),t("ul",[t("li",[a._v("hash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中。它是用来指导浏览器动作的，对服务器端完全无用，因此，改变 hash 不会重新加载页面")]),a._v(" "),t("li",[a._v("可以为 hash 的改变添加监听事件：")])]),a._v(" "),t("div",{staticClass:"language-javascript extra-class"},[t("pre",{pre:!0,attrs:{class:"language-javascript"}},[t("code",[a._v("window"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("addEventListener")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[a._v("'hashchange'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" funcRef"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token boolean"}},[a._v("false")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n")])])]),t("ul",[t("li",[a._v("每一次改变 hash（window.location.hash），都会在浏览器的访问历史中增加一个记录")])]),a._v(" "),t("p",[a._v("利用 hash 的以上特点，就可以来实现前端路由“更新视图但不重新请求页面”的功能了。")]),a._v(" "),t("h2",{attrs:{id:"history-模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#history-模式"}},[a._v("#")]),a._v(" history 模式")]),a._v(" "),t("p",[a._v("我们先介绍一下 H5 新推出的两个 api：pushState 与 replaceState")]),a._v(" "),t("p",[a._v("作用就是可以将 url 替换并且不刷新页面，好比挂羊头卖狗肉，http 并没有去请求服务器该路径下的资源，一旦刷新就会暴露这个实际不存在的“羊头”，显示 404。")]),a._v(" "),t("p",[a._v("那么如何去解决 history 模式下刷新报 404 的弊端呢，这就需要服务器端做点手脚，将不存在的路径请求重定向到入口文件（index.html），前后端联手，齐心协力做好“挂羊头卖狗肉”的完美特效。")])])}),[],!1,null,null,null);t.default=e.exports}}]);